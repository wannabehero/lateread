import { sql } from "drizzle-orm";
import { index, integer, sqliteTable, text } from "drizzle-orm/sqlite-core";

// Users table - auth-agnostic user records
export const users = sqliteTable("users", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
});

// Telegram users table - links Telegram accounts to users
export const telegramUsers = sqliteTable(
  "telegram_users",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    telegramId: text("telegram_id").notNull().unique(),
    username: text("username"),
    firstName: text("first_name"),
    lastName: text("last_name"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("telegram_users_user_id_idx").on(table.userId),
    index("telegram_users_telegram_id_idx").on(table.telegramId),
  ],
);

// Article status enum
export const articleStatus = [
  "pending",
  "processing",
  "completed",
  "failed",
  "error",
] as const;

// Articles table - saved articles with metadata
export const articles = sqliteTable(
  "articles",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    url: text("url").notNull(),
    title: text("title"),
    description: text("description"),
    imageUrl: text("image_url"),
    siteName: text("site_name"),
    language: text("language"),
    status: text("status", { enum: articleStatus })
      .notNull()
      .default("pending"),
    archived: integer("archived", { mode: "boolean" }).notNull().default(false),
    processingAttempts: integer("processing_attempts").notNull().default(0),
    lastError: text("last_error"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
    processedAt: integer("processed_at", { mode: "timestamp" }),
    readAt: integer("read_at", { mode: "timestamp" }),
    updatedAt: integer("updated_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("articles_user_id_idx").on(table.userId),
    index("articles_status_idx").on(table.status),
    index("articles_archived_idx").on(table.archived),
    index("articles_created_at_idx").on(table.createdAt),
  ],
);

// Tags table - user-specific tags
export const tags = sqliteTable(
  "tags",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    autoGenerated: integer("auto_generated", { mode: "boolean" })
      .notNull()
      .default(true),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("tags_user_id_idx").on(table.userId),
    index("tags_user_id_name_idx").on(table.userId, table.name),
  ],
);

// Article-Tag junction table (many-to-many)
export const articleTags = sqliteTable(
  "article_tags",
  {
    articleId: text("article_id")
      .notNull()
      .references(() => articles.id, { onDelete: "cascade" }),
    tagId: text("tag_id")
      .notNull()
      .references(() => tags.id, { onDelete: "cascade" }),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("article_tags_article_id_idx").on(table.articleId),
    index("article_tags_tag_id_idx").on(table.tagId),
  ],
);

// Article summaries table - cached LLM-generated summaries
export const articleSummaries = sqliteTable(
  "article_summaries",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    articleId: text("article_id")
      .notNull()
      .unique()
      .references(() => articles.id, { onDelete: "cascade" }),
    oneSentence: text("one_sentence").notNull(),
    oneParagraph: text("one_paragraph").notNull(),
    long: text("long").notNull(),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [index("article_summaries_article_id_idx").on(table.articleId)],
);

// Auth tokens table - for Telegram-based authentication
export const authTokens = sqliteTable(
  "auth_tokens",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    token: text("token").notNull().unique(),
    userId: text("user_id").references(() => users.id, { onDelete: "cascade" }),
    expiresAt: integer("expires_at", { mode: "timestamp" }).notNull(),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("auth_tokens_token_idx").on(table.token),
    index("auth_tokens_expires_at_idx").on(table.expiresAt),
  ],
);
