import { beforeEach, describe, expect, it, mock } from "bun:test";
import { createTag, createUser } from "../../test/fixtures";
import { createTestDatabase, resetDatabase } from "../../test/setup";
import { deleteTag, getOrCreateTag, getUserTags } from "./tags.service";

// Create test database
const testDb = createTestDatabase();
const { db } = testDb;

// Mock the db import
mock.module("../lib/db", () => ({
  db,
  tags: require("../db/schema").tags,
}));

describe("tags.service", () => {
  beforeEach(async () => {
    await resetDatabase(db);
  });

  describe("getUserTags", () => {
    it("should return all tags for a user", async () => {
      const user = await createUser(db);

      await createTag(db, user.id, "javascript");
      await createTag(db, user.id, "typescript");
      await createTag(db, user.id, "react");

      const tags = await getUserTags(user.id);

      expect(tags).toHaveLength(3);
      expect(tags.map((t) => t.name).sort()).toEqual([
        "javascript",
        "react",
        "typescript",
      ]);
    });

    it("should return empty array for user with no tags", async () => {
      const user = await createUser(db);
      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(0);
    });

    it("should only return tags for the specified user", async () => {
      const user1 = await createUser(db);
      const user2 = await createUser(db);

      await createTag(db, user1.id, "user1-tag");
      await createTag(db, user2.id, "user2-tag");

      const user1Tags = await getUserTags(user1.id);
      const user2Tags = await getUserTags(user2.id);

      expect(user1Tags).toHaveLength(1);
      expect(user1Tags[0]?.name).toBe("user1-tag");

      expect(user2Tags).toHaveLength(1);
      expect(user2Tags[0]?.name).toBe("user2-tag");
    });

    it("should return tags with all expected properties", async () => {
      const user = await createUser(db);
      await createTag(db, user.id, "test-tag", { autoGenerated: false });

      const tags = await getUserTags(user.id);

      expect(tags).toHaveLength(1);
      const tag = tags[0];
      expect(tag?.id).toBeDefined();
      expect(tag?.userId).toBe(user.id);
      expect(tag?.name).toBe("test-tag");
      expect(tag?.autoGenerated).toBe(false);
      expect(tag?.createdAt).toBeInstanceOf(Date);
    });

    it("should return both auto-generated and manual tags", async () => {
      const user = await createUser(db);

      await createTag(db, user.id, "auto-tag", { autoGenerated: true });
      await createTag(db, user.id, "manual-tag", { autoGenerated: false });

      const tags = await getUserTags(user.id);

      expect(tags).toHaveLength(2);

      const autoTag = tags.find((t) => t.name === "auto-tag");
      const manualTag = tags.find((t) => t.name === "manual-tag");

      expect(autoTag?.autoGenerated).toBe(true);
      expect(manualTag?.autoGenerated).toBe(false);
    });
  });

  describe("getOrCreateTag", () => {
    it("should create a new tag if it does not exist", async () => {
      const user = await createUser(db);

      const tagId = await getOrCreateTag(user.id, "new-tag");

      expect(tagId).toBeDefined();

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(1);
      expect(tags[0]?.name).toBe("new-tag");
      expect(tags[0]?.id).toBe(tagId);
    });

    it("should return existing tag ID if tag exists", async () => {
      const user = await createUser(db);

      const existingTag = await createTag(db, user.id, "existing-tag");

      const tagId = await getOrCreateTag(user.id, "existing-tag");

      expect(tagId).toBe(existingTag.id);

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(1); // Should not create duplicate
    });

    it("should normalize tag names to lowercase", async () => {
      const user = await createUser(db);

      await getOrCreateTag(user.id, "JavaScript");

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(1);
      expect(tags[0]?.name).toBe("javascript"); // Stored as lowercase
    });

    it("should be case-insensitive when checking existing tags", async () => {
      const user = await createUser(db);

      const tag1Id = await getOrCreateTag(user.id, "TypeScript");
      const tag2Id = await getOrCreateTag(user.id, "typescript");
      const tag3Id = await getOrCreateTag(user.id, "TYPESCRIPT");

      expect(tag1Id).toBe(tag2Id);
      expect(tag2Id).toBe(tag3Id);

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(1); // Only one tag created
      expect(tags[0]?.name).toBe("typescript");
    });

    it("should set autoGenerated flag correctly", async () => {
      const user = await createUser(db);

      const autoTagId = await getOrCreateTag(user.id, "auto-tag", true);
      const manualTagId = await getOrCreateTag(user.id, "manual-tag", false);

      const tags = await getUserTags(user.id);

      const autoTag = tags.find((t) => t.id === autoTagId);
      const manualTag = tags.find((t) => t.id === manualTagId);

      expect(autoTag?.autoGenerated).toBe(true);
      expect(manualTag?.autoGenerated).toBe(false);
    });

    it("should default to autoGenerated=true", async () => {
      const user = await createUser(db);

      const tagId = await getOrCreateTag(user.id, "default-tag");

      const tags = await getUserTags(user.id);
      const tag = tags.find((t) => t.id === tagId);

      expect(tag?.autoGenerated).toBe(true);
    });

    it("should isolate tags between users", async () => {
      const user1 = await createUser(db);
      const user2 = await createUser(db);

      const tag1Id = await getOrCreateTag(user1.id, "shared-name");
      const tag2Id = await getOrCreateTag(user2.id, "shared-name");

      expect(tag1Id).not.toBe(tag2Id);

      const user1Tags = await getUserTags(user1.id);
      const user2Tags = await getUserTags(user2.id);

      expect(user1Tags).toHaveLength(1);
      expect(user2Tags).toHaveLength(1);
      expect(user1Tags[0]?.id).toBe(tag1Id);
      expect(user2Tags[0]?.id).toBe(tag2Id);
    });

    it("should handle tags with special characters", async () => {
      const user = await createUser(db);

      await getOrCreateTag(user.id, "C++ Programming");

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(1);
      expect(tags[0]?.name).toBe("c++ programming");
    });

    it("should handle tags with spaces", async () => {
      const user = await createUser(db);

      await getOrCreateTag(user.id, "Machine Learning");

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(1);
      expect(tags[0]?.name).toBe("machine learning");
    });

    it("should trim whitespace from tag names", async () => {
      const user = await createUser(db);

      await getOrCreateTag(user.id, "  javascript  ");
      await getOrCreateTag(user.id, "javascript");

      // Note: The current implementation doesn't trim, so this test
      // documents actual behavior. If trimming is desired, update implementation.
      const tags = await getUserTags(user.id);

      // Current behavior: creates two separate tags
      // If you want to change this, update getOrCreateTag to trim inputs
      expect(tags.length).toBeGreaterThanOrEqual(1);
    });
  });

  describe("deleteTag", () => {
    it("should delete a tag", async () => {
      const user = await createUser(db);
      const tag = await createTag(db, user.id, "to-delete");

      await deleteTag(tag.id, user.id);

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(0);
    });

    it("should only delete tag for the specified user", async () => {
      const user1 = await createUser(db);
      const user2 = await createUser(db);

      const tag1 = await createTag(db, user1.id, "tag1");
      const tag2 = await createTag(db, user2.id, "tag2");

      // Try to delete user1's tag as user2 (should not delete)
      await deleteTag(tag1.id, user2.id);

      const user1Tags = await getUserTags(user1.id);
      expect(user1Tags).toHaveLength(1); // Tag still exists

      // Delete user2's tag as user2 (should delete)
      await deleteTag(tag2.id, user2.id);

      const user2Tags = await getUserTags(user2.id);
      expect(user2Tags).toHaveLength(0);
    });

    it("should not throw when deleting non-existent tag", async () => {
      const user = await createUser(db);

      // Should not throw
      await deleteTag("non-existent-id", user.id);

      expect(true).toBe(true);
    });

    it("should delete only the specified tag", async () => {
      const user = await createUser(db);

      await createTag(db, user.id, "tag1");
      const tag2 = await createTag(db, user.id, "tag2");
      await createTag(db, user.id, "tag3");

      await deleteTag(tag2.id, user.id);

      const tags = await getUserTags(user.id);
      expect(tags).toHaveLength(2);

      const tagNames = tags.map((t) => t.name).sort();
      expect(tagNames).toEqual(["tag1", "tag3"]);
    });
  });
});
