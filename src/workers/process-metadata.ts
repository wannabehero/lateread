import { and, eq, sql } from "drizzle-orm";
import { articles, articleTags, tags } from "../db/schema";
import { config } from "../lib/config";
import { contentCache } from "../lib/content-cache";
import { db } from "../lib/db";
import { getLLMProvider } from "../lib/llm";
import { extractCleanContent } from "../lib/readability";

self.onmessage = async (event: MessageEvent) => {
  const { articleId } = event.data;

  try {
    // Step 1: Fetch article from database
    const [article] = await db
      .select()
      .from(articles)
      .where(eq(articles.id, articleId))
      .limit(1);

    if (!article) {
      throw new Error(`Article not found: ${articleId}`);
    }

    // Early exit if already completed
    if (article.status === "completed") {
      self.postMessage({ success: true, articleId });
      return;
    }

    // Step 2: Update status to 'processing', increment attempts
    await db
      .update(articles)
      .set({
        status: "processing",
        processingAttempts: article.processingAttempts + 1,
        updatedAt: new Date(),
      })
      .where(eq(articles.id, articleId));

    // Set up timeout
    const timeoutMs = config.PROCESSING_TIMEOUT_SECONDS * 1000;
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Processing timeout")), timeoutMs),
    );

    // Process article with timeout
    await Promise.race([processArticle(article), timeoutPromise]);

    // Step 9: Post success message
    self.postMessage({ success: true, articleId });
  } catch (error) {
    // Error handling
    console.error(`Article processing failed for ${articleId}:`, error);

    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    try {
      await db
        .update(articles)
        .set({
          status: "failed",
          lastError: errorMessage,
          updatedAt: new Date(),
        })
        .where(eq(articles.id, articleId));
    } catch (dbError) {
      console.error("Failed to update article status:", dbError);
    }

    self.postMessage({
      success: false,
      articleId,
      error: errorMessage,
    });
  }
};

async function processArticle(article: any) {
  // Step 3: Fetch URL content
  const extracted = await extractCleanContent(article.url);

  if (!extracted.textContent || !extracted.content) {
    console.error(`Failed to extract content from ${article.url}`);
    return;
  }

  // Step 4: Metadata already extracted by readability wrapper

  // Step 5: Generate tags using LLM
  const llmProvider = await getLLMProvider();

  // Load user's existing tags
  const existingTagRecords = await db
    .select()
    .from(tags)
    .where(eq(tags.userId, article.userId));

  const existingTagNames = existingTagRecords.map((t) => t.name);

  // Call LLM to extract tags
  const { tags: extractedTags } = await llmProvider.extractTags(
    extracted.textContent,
    existingTagNames,
  );

  // Process tags: create new ones or reuse existing
  const tagIds: string[] = [];

  for (const tagName of extractedTags) {
    const normalizedTagName = tagName.toLowerCase();

    // Check if tag exists (case-insensitive)
    const [existingTag] = await db
      .select()
      .from(tags)
      .where(
        and(
          eq(tags.userId, article.userId),
          sql`lower(${tags.name}) = ${normalizedTagName}`,
        ),
      )
      .limit(1);

    if (existingTag) {
      tagIds.push(existingTag.id);
    } else {
      // Create new tag
      const [newTag] = await db
        .insert(tags)
        .values({
          userId: article.userId,
          name: normalizedTagName,
          autoGenerated: true,
        })
        .returning();

      if (newTag) {
        tagIds.push(newTag.id);
      }
    }
  }

  // Step 6: Cache clean HTML content
  await contentCache.set(article.id, extracted.content);

  // Step 7: Update database in transaction
  await db.transaction(async (tx) => {
    // Update article metadata
    await tx
      .update(articles)
      .set({
        title: extracted.title,
        description: extracted.description,
        imageUrl: extracted.imageUrl,
        siteName: extracted.siteName,
        status: "completed",
        processedAt: new Date(),
        updatedAt: new Date(),
        lastError: null,
      })
      .where(eq(articles.id, article.id));

    // Delete existing article-tag associations (in case of retry)
    await tx.delete(articleTags).where(eq(articleTags.articleId, article.id));

    // Insert new article-tag associations
    if (tagIds.length > 0) {
      await tx.insert(articleTags).values(
        tagIds.map((tagId) => ({
          articleId: article.id,
          tagId,
        })),
      );
    }
  });
}
