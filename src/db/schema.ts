import { sql } from "drizzle-orm";
import { index, integer, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const users = sqliteTable("users", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
  preferences: text("preferences").notNull().default("{}"),
});

export const subscriptionType = ["full", "lite"] as const;

export const subscriptions = sqliteTable(
  "subscriptions",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: text("type", { enum: subscriptionType }).notNull().default("lite"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
    expiresAt: integer("expires_at", { mode: "timestamp" }).notNull(),
  },
  (table) => [index("subscriptions_user_id_idx").on(table.userId)],
);

export const telegramUsers = sqliteTable(
  "telegram_users",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    telegramId: text("telegram_id").notNull().unique(),
    username: text("username"),
    firstName: text("first_name"),
    lastName: text("last_name"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("telegram_users_user_id_idx").on(table.userId),
    index("telegram_users_telegram_id_idx").on(table.telegramId),
  ],
);

export const articleStatus = [
  "pending",
  "processing",
  "completed",
  "failed",
  "error",
] as const;

export const articles = sqliteTable(
  "articles",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    url: text("url").notNull(),
    title: text("title"),
    description: text("description"),
    imageUrl: text("image_url"),
    siteName: text("site_name"),
    language: text("language"),
    status: text("status", { enum: articleStatus })
      .notNull()
      .default("pending"),
    archived: integer("archived", { mode: "boolean" }).notNull().default(false),
    rating: integer("rating").notNull().default(0), // -1 = dislike, 0 = none, 1 = like
    processingAttempts: integer("processing_attempts").notNull().default(0),
    lastError: text("last_error"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
    processedAt: integer("processed_at", { mode: "timestamp" }),
    readAt: integer("read_at", { mode: "timestamp" }),
    updatedAt: integer("updated_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
    wordCount: integer("word_count"),
    readingTimeSeconds: integer("reading_time_seconds"),
    readingPositionElement: integer("reading_position_element"),
    readingPositionOffset: integer("reading_position_offset"),
  },
  (table) => [
    index("articles_user_id_idx").on(table.userId),
    index("articles_status_idx").on(table.status),
    index("articles_archived_idx").on(table.archived),
    index("articles_rating_idx").on(table.rating),
    index("articles_created_at_idx").on(table.createdAt),
  ],
);

export const tags = sqliteTable(
  "tags",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    autoGenerated: integer("auto_generated", { mode: "boolean" })
      .notNull()
      .default(true),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("tags_user_id_idx").on(table.userId),
    index("tags_user_id_name_idx").on(table.userId, table.name),
  ],
);

export const articleTags = sqliteTable(
  "article_tags",
  {
    articleId: text("article_id")
      .notNull()
      .references(() => articles.id, { onDelete: "cascade" }),
    tagId: text("tag_id")
      .notNull()
      .references(() => tags.id, { onDelete: "cascade" }),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("article_tags_article_id_idx").on(table.articleId),
    index("article_tags_tag_id_idx").on(table.tagId),
  ],
);

export const articleSummaries = sqliteTable(
  "article_summaries",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    articleId: text("article_id")
      .notNull()
      .unique()
      .references(() => articles.id, { onDelete: "cascade" }),
    oneSentence: text("one_sentence").notNull(),
    oneParagraph: text("one_paragraph").notNull(),
    long: text("long").notNull(),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [index("article_summaries_article_id_idx").on(table.articleId)],
);

export const authTokens = sqliteTable(
  "auth_tokens",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    token: text("token").notNull().unique(),
    userId: text("user_id").references(() => users.id, { onDelete: "cascade" }),
    expiresAt: integer("expires_at", { mode: "timestamp" }).notNull(),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`(unixepoch())`),
  },
  (table) => [
    index("auth_tokens_token_idx").on(table.token),
    index("auth_tokens_expires_at_idx").on(table.expiresAt),
  ],
);
