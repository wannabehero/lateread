import { beforeEach, describe, expect, it } from "bun:test";
import { eq } from "drizzle-orm";
import {
  addTagToArticle,
  createArticle,
  createTag,
  createUser,
} from "../../test/fixtures";
import { createTestDatabase, resetDatabase } from "../../test/setup";
import * as schema from "./schema";

const testDb = createTestDatabase();
const { db } = testDb;

describe("database schema", () => {
  beforeEach(async () => {
    await resetDatabase(db);
  });

  describe("telegramUsers table", () => {
    it("should enforce unique telegramId", async () => {
      const user1 = await createUser(db);
      const user2 = await createUser(db);

      await db.insert(schema.telegramUsers).values({
        userId: user1.id,
        telegramId: "123456789",
        username: "testuser1",
        firstName: "Test",
        lastName: "User",
      });

      // Try to insert duplicate telegramId
      let error: Error | null = null;
      try {
        await db.insert(schema.telegramUsers).values({
          userId: user2.id,
          telegramId: "123456789",
          username: "testuser2",
          firstName: "Test",
          lastName: "User",
        });
      } catch (e) {
        error = e as Error;
      }

      expect(error).not.toBeNull();
      expect(error?.message).toContain("UNIQUE");
    });

    it("should cascade delete when user is deleted", async () => {
      const user = await createUser(db);
      await db.insert(schema.telegramUsers).values({
        userId: user.id,
        telegramId: "123456789",
        username: "testuser",
        firstName: "Test",
        lastName: "User",
      });

      // Delete user
      await db.delete(schema.users).where(eq(schema.users.id, user.id));

      // TelegramUser should be deleted too
      const telegramUsers = await db
        .select()
        .from(schema.telegramUsers)
        .where(eq(schema.telegramUsers.userId, user.id));

      expect(telegramUsers).toHaveLength(0);
    });
  });

  describe("articles table", () => {
    it("should default status to pending", async () => {
      const user = await createUser(db);
      const [article] = await db
        .insert(schema.articles)
        .values({
          userId: user.id,
          url: "https://example.com",
        })
        .returning();

      expect(article?.status).toBe("pending");
    });

    it("should default processingAttempts to 0", async () => {
      const user = await createUser(db);
      const [article] = await db
        .insert(schema.articles)
        .values({
          userId: user.id,
          url: "https://example.com",
        })
        .returning();

      expect(article?.processingAttempts).toBe(0);
    });
  });

  describe("tags table", () => {
    it("should allow same tag name for different users", async () => {
      const user1 = await createUser(db);
      const user2 = await createUser(db);

      const tag1 = await createTag(db, user1.id, "javascript");
      const tag2 = await createTag(db, user2.id, "javascript");

      expect(tag1.name).toBe("javascript");
      expect(tag2.name).toBe("javascript");
      expect(tag1.id).not.toBe(tag2.id);
    });

    it("should default autoGenerated to true", async () => {
      const user = await createUser(db);
      const [tag] = await db
        .insert(schema.tags)
        .values({
          userId: user.id,
          name: "test",
        })
        .returning();

      expect(tag?.autoGenerated).toBe(true);
    });
  });

  describe("articleTags junction table", () => {
    it("should associate articles with tags", async () => {
      const user = await createUser(db);
      const article = await createArticle(db, user.id);
      const tag = await createTag(db, user.id, "test");

      await addTagToArticle(db, article.id, tag.id);

      const articleTags = await db
        .select()
        .from(schema.articleTags)
        .where(eq(schema.articleTags.articleId, article.id));

      expect(articleTags).toHaveLength(1);
      expect(articleTags[0]?.tagId).toBe(tag.id);
    });

    it("should cascade delete when article is deleted", async () => {
      const user = await createUser(db);
      const article = await createArticle(db, user.id);
      const tag = await createTag(db, user.id, "test");

      await addTagToArticle(db, article.id, tag.id);

      // Delete article
      await db
        .delete(schema.articles)
        .where(eq(schema.articles.id, article.id));

      // ArticleTag should be deleted too
      const articleTags = await db
        .select()
        .from(schema.articleTags)
        .where(eq(schema.articleTags.articleId, article.id));

      expect(articleTags).toHaveLength(0);
    });

    it("should cascade delete when tag is deleted", async () => {
      const user = await createUser(db);
      const article = await createArticle(db, user.id);
      const tag = await createTag(db, user.id, "test");

      await addTagToArticle(db, article.id, tag.id);

      // Delete tag
      await db.delete(schema.tags).where(eq(schema.tags.id, tag.id));

      // ArticleTag should be deleted too
      const articleTags = await db
        .select()
        .from(schema.articleTags)
        .where(eq(schema.articleTags.articleId, article.id));

      expect(articleTags).toHaveLength(0);
    });
  });

  describe("articleSummaries table", () => {
    it("should cascade delete when article is deleted", async () => {
      const user = await createUser(db);
      const article = await createArticle(db, user.id);

      await db.insert(schema.articleSummaries).values({
        articleId: article.id,
        oneSentence: "Test summary",
        oneParagraph: "Test paragraph",
        long: "Test long summary",
      });

      // Delete article
      await db
        .delete(schema.articles)
        .where(eq(schema.articles.id, article.id));

      // Summary should be deleted too
      const summaries = await db
        .select()
        .from(schema.articleSummaries)
        .where(eq(schema.articleSummaries.articleId, article.id));

      expect(summaries).toHaveLength(0);
    });
  });

  describe("authTokens table", () => {
    it("should allow nullable userId", async () => {
      const [token] = await db
        .insert(schema.authTokens)
        .values({
          token: "test-token",
          userId: null,
          expiresAt: new Date(Date.now() + 5 * 60 * 1000),
        })
        .returning();

      expect(token?.userId).toBeNull();
    });

    it("should allow setting userId after creation", async () => {
      const user = await createUser(db);

      await db.insert(schema.authTokens).values({
        token: "test-token",
        userId: null,
        expiresAt: new Date(Date.now() + 5 * 60 * 1000),
      });

      // Update with userId
      await db
        .update(schema.authTokens)
        .set({ userId: user.id })
        .where(eq(schema.authTokens.token, "test-token"));

      const [updated] = await db
        .select()
        .from(schema.authTokens)
        .where(eq(schema.authTokens.token, "test-token"));

      expect(updated?.userId).toBe(user.id);
    });
  });
});
