import { randomUUID } from "node:crypto";
import type { drizzle } from "drizzle-orm/bun-sqlite";
import { Window } from "happy-dom";
import * as schema from "../src/db/schema";
import type { Logger } from "../src/lib/logger/types";
import { createSessionCookie, getSessionCookieName } from "../src/lib/session";

type DB = ReturnType<typeof drizzle<typeof schema>>;
/**
 * Create a test user
 */
export async function createUser(
  db: DB,
  overrides?: Partial<typeof schema.users.$inferInsert>,
): Promise<typeof schema.users.$inferSelect> {
  const id = overrides?.id ?? randomUUID();
  const createdAt = overrides?.createdAt ?? new Date();
  const preferences = overrides?.preferences ?? "{}";

  const [user] = await db
    .insert(schema.users)
    .values({ id, createdAt, preferences })
    .returning();

  if (!user) throw new Error("Failed to create user");
  return user;
}

/**
 * Create a test article
 */
export async function createArticle(
  db: DB,
  userId: string,
  overrides?: Partial<typeof schema.articles.$inferInsert>,
): Promise<typeof schema.articles.$inferSelect> {
  const id = overrides?.id ?? randomUUID();
  const url = overrides?.url ?? `https://example.com/article-${id.slice(0, 8)}`;
  const title = overrides?.title ?? null;
  const description = overrides?.description ?? null;
  const siteName = overrides?.siteName ?? null;
  const imageUrl = overrides?.imageUrl ?? null;
  const language = overrides?.language ?? null;
  const status = overrides?.status ?? "pending";
  const lastError = overrides?.lastError ?? null;
  const createdAt = overrides?.createdAt ?? new Date();

  const [article] = await db
    .insert(schema.articles)
    .values({
      id,
      userId,
      url,
      title,
      description,
      siteName,
      imageUrl,
      language,
      status,
      lastError,
      createdAt,
    })
    .returning();

  if (!article) throw new Error("Failed to create article");
  return article;
}

/**
 * Create a completed article with metadata
 */
export async function createCompletedArticle(
  db: DB,
  userId: string,
  overrides?: Partial<typeof schema.articles.$inferInsert>,
): Promise<typeof schema.articles.$inferSelect> {
  const id = overrides?.id ?? randomUUID();
  const url = overrides?.url ?? `https://example.com/article-${id.slice(0, 8)}`;
  const title = overrides?.title ?? "Test Article Title";
  const description = overrides?.description ?? "Test article description";
  const siteName = overrides?.siteName ?? "Example Site";
  const imageUrl = overrides?.imageUrl ?? "https://example.com/image.jpg";

  const [article] = await db
    .insert(schema.articles)
    .values({
      id,
      userId,
      url,
      title,
      description,
      siteName,
      imageUrl,
      status: "completed",
      processedAt: new Date(),
      createdAt: new Date(),
      archived: overrides?.archived ?? false,
      language: overrides?.language ?? null,
      readAt: overrides?.readAt ?? null,
    })
    .returning();

  if (!article) throw new Error("Failed to create completed article");
  return article;
}

/**
 * Create a test tag
 */
export async function createTag(
  db: DB,
  userId: string,
  name: string,
  overrides?: Partial<typeof schema.tags.$inferInsert>,
): Promise<typeof schema.tags.$inferSelect> {
  const id = overrides?.id ?? randomUUID();
  const normalizedName = name.toLowerCase();

  const [tag] = await db
    .insert(schema.tags)
    .values({
      id,
      userId,
      name: normalizedName,
      autoGenerated: overrides?.autoGenerated ?? true,
    })
    .returning();

  if (!tag) throw new Error("Failed to create tag");
  return tag;
}

/**
 * Associate a tag with an article
 */
export async function addTagToArticle(
  db: DB,
  articleId: string,
  tagId: string,
): Promise<void> {
  await db.insert(schema.articleTags).values({ articleId, tagId });
}

/**
 * Create a test subscription
 */
export async function createSubscription(
  db: DB,
  userId: string,
  overrides?: Partial<typeof schema.subscriptions.$inferInsert>,
): Promise<typeof schema.subscriptions.$inferSelect> {
  const id = overrides?.id ?? randomUUID();
  const type = overrides?.type ?? "lite";
  const createdAt = overrides?.createdAt ?? new Date();
  // Default to 30 days in the future (use setSystemTime in tests for deterministic dates)
  const expiresAt =
    overrides?.expiresAt ?? new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

  const [subscription] = await db
    .insert(schema.subscriptions)
    .values({
      id,
      userId,
      type,
      createdAt,
      expiresAt,
    })
    .returning();

  if (!subscription) throw new Error("Failed to create subscription");
  return subscription;
}

/**
 * Create a test telegram user
 */
export async function createTelegramUser(
  db: DB,
  userId: string,
  telegramId: string,
  overrides?: Partial<typeof schema.telegramUsers.$inferInsert>,
): Promise<typeof schema.telegramUsers.$inferSelect> {
  const id = overrides?.id ?? randomUUID();
  const createdAt = overrides?.createdAt ?? new Date();

  const [telegramUser] = await db
    .insert(schema.telegramUsers)
    .values({
      id,
      userId,
      telegramId,
      username: overrides?.username ?? null,
      firstName: overrides?.firstName ?? null,
      lastName: overrides?.lastName ?? null,
      createdAt,
    })
    .returning();

  if (!telegramUser) throw new Error("Failed to create telegram user");
  return telegramUser;
}

export function createNoopLogger(): Logger {
  return {
    debug: () => {},
    info: () => {},
    warn: () => {},
    error: () => {},
    child: () => createNoopLogger(),
    context: {},
  };
}

/**
 * Parse HTML string into a DOM Document for testing
 * Uses happy-dom's Window directly (not GlobalRegistrator) to avoid parallel test conflicts
 */
export function parseHtml(html: string): Document {
  const window = new Window();
  window.document.write(html);
  return window.document as unknown as Document;
}

/**
 * Create headers with a valid session cookie for authenticated requests
 * Use this in tests to authenticate requests without mocking
 *
 * @example
 * const headers = createAuthHeaders(testUserId);
 * const res = await app.request("/articles", { headers });
 */
export function createAuthHeaders(userId: string): HeadersInit {
  const sessionCookie = createSessionCookie(userId);
  const cookieName = getSessionCookieName();
  return {
    Cookie: `${cookieName}=${sessionCookie}`,
  };
}
